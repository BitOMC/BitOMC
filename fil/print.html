<!DOCTYPE HTML>
<html lang="fil" class="coal" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BitOMC Handbook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="language-picker.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "coal";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('coal')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Panimula</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Pangkalahatang-ideya</a></li><li class="chapter-item expanded "><a href="bitomc.html"><strong aria-hidden="true">2.</strong> BitOMC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bitomc/specification.html"><strong aria-hidden="true">2.1.</strong> Pagtutukoy</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">3.</strong> Mag-ambag</a></li><li class="chapter-item expanded "><a href="guides.html"><strong aria-hidden="true">4.</strong> Mga gabay</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guides/wallet.html"><strong aria-hidden="true">4.1.</strong> Wallet</a></li><li class="chapter-item expanded "><a href="guides/reindexing.html"><strong aria-hidden="true">4.2.</strong> Reindexing</a></li><li class="chapter-item expanded "><a href="guides/settings.html"><strong aria-hidden="true">4.3.</strong> Settings</a></li><li class="chapter-item expanded "><a href="guides/testing.html"><strong aria-hidden="true">4.4.</strong> Pagsuri</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BitOMC Handbook</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="de">Deutsch</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="fr">Français</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="es">Español</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="pt">Português</a>
                          </button></li>
                           <li role="none"><button role="menuitem" class="theme">
                              <a id="ru">Русский</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh">中文版</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ja">日本語版</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ko">한국어</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="fil">Filipino</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ar">العربية</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="hi">हिंदी</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="it">Italiano</a>
                          </button></li>
                        </ul>

                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("fil");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "../";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BitOMC/BitOMC" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="panimula"><a class="header" href="#panimula">Panimula</a></h1>
<p>This handbook is a guide to BitOMC, a metaprotocol on Bitcoin that facilitates the creation of a more stable unit of account for Bitcoin payments.</p>
<p>In a world with ever-changing economic conditions, Bitcoin's fixed supply makes it unattractive as a unit of account in contracts where payment is due in the future. BitOMC addresses this by defining a market-driven unit of account that can facilitate price stability in a Bitcoin economy, without changing Bitcoin's core protocol.</p>
<p>BitOMC uses two interconvertible assets, Tighten and Ease, to establish a dynamic interest rate and a new unit of Bitcoin called the "util". Tighten and Ease are transferable on Bitcoin using rules nearly identical to those used by the Runes protocol.</p>
<p>BitOMC is not premined. Users can mint Tighten and Ease once per block according to the same four-year halving schedule as Bitcoin. To limit network congestion and MEV, mint and conversion transactions leave a small anchor output, which must be spent by the next respective transaction.</p>
<p>For more high-level details, see the <a href="overview.html">overview</a>.</p>
<p>For details on the specification, see <a href="bitomc.html">bitomc</a>.</p>
<p>When you're ready to get your hands dirty, a good place to start is by <a href="guides/wallet.html">minting</a>.</p>
<h2 id="mga-link"><a class="header" href="#mga-link">Mga Link</a></h2>
<ul>
<li><a href="https://github.com/BitOMC/BitOMC/">GitHub</a></li>
<li><a href="https://bitomc.org/bitomc.pdf">BitOMC Whitepaper</a></li>
<li><a href="https://t.me/bitOMC_chat">BitOMC Telegram group</a></li>
<li><a href="https://bitomc.org/">BitOMC Website</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitomc-overview"><a class="header" href="#bitomc-overview">BitOMC Overview</a></h1>
<p>BitOMC is a fork of the <a href="https://docs.ordinals.com/runes.html">Runes protocol</a>, consisting of two interconvertible assets, Tighten and Ease, which users can convert between according to a constant function conversion rule. This keeps the system in balance and ensures the conversion rate reflects their relative market price. This conversion rate determines a dynamic interest rate, which in turn defines a floating unit of Bitcoin called the "util". Transactions continue to settle in Bitcoin, but parties seeking greater price stability may choose to denominate their contracts in "utils" rather than BTC or a fiat currency.</p>
<p>Technical details are available in <a href="https://bitomc.org/bitomc.pdf">the whitepaper</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitomc"><a class="header" href="#bitomc">BitOMC</a></h1>
<p>BitOMC is a fork of the <a href="https://docs.ordinals.com/runes.html">Runes protocol</a>. Runes allow Bitcoin transactions to mint, transfer, and convert Bitcoin-native digital commodities. There are only two runes in BitOMC, Tighten and Ease.</p>
<h2 id="runestones"><a class="header" href="#runestones">Runestones</a></h2>
<p>Protocol messages, called runestones, are stored in Bitcoin transaction outputs.</p>
<p>In BitOMC, a runestone output's script pubkey begins with an <code>OP_RETURN</code>, followed by <code>OP_14</code>, followed by zero or more data pushes. These data pushes are concatenated and decoded into a sequence of 128-bit integers, and finally parsed into a runestone.</p>
<p>A transaction may have at most one runestone.</p>
<p>A runestone may mint an existing rune, transfer runes from a transaction's inputs to its outputs, and convert from one rune to another.</p>
<p>A transaction output may hold balances of any number of runes.</p>
<p>Runes are identified by IDs. The IDs of Tighten and Ease are <code>1:0</code> and <code>1:1</code>, respectively.</p>
<h2 id="minting"><a class="header" href="#minting">Minting</a></h2>
<p>Anyone may create a mint transaction that mints the amount of Tighten and Ease available in the block the transaction is mined, plus any amount of Tighten and Ease that has been burned. The issuance of Tighten and Ease follows a four-year halving schedule as outlined in <a href="https://bitomc.org/bitomc.pdf">the whitepaper</a>.</p>
<h2 id="transferring"><a class="header" href="#transferring">Transferring</a></h2>
<p>When transaction inputs contain runes, or new runes are created by a mint, those runes are transferred to that transaction's outputs. A transaction's runestone may change how input runes transfer to outputs.</p>
<h3 id="edicts"><a class="header" href="#edicts">Edicts</a></h3>
<p>A runestone may contain any number of edicts. Edicts consist of a rune ID, an amount, and an output number. Edicts are processed in order, allocating unallocated runes to outputs.</p>
<h3 id="pointer"><a class="header" href="#pointer">Pointer</a></h3>
<p>After all edicts are processed, remaining unallocated runes are transferred to the transaction's first non-<code>OP_RETURN</code> output. A runestone may optionally contain a pointer that specifies an alternative default output.</p>
<h3 id="burning"><a class="header" href="#burning">Burning</a></h3>
<p>Runes may be burned by transferring them to an <code>OP_RETURN</code> output with an edict or pointer.</p>
<h2 id="converting"><a class="header" href="#converting">Converting</a></h2>
<p>When runes of one ID are burned and runes of another are transferred in excess of their input balance, those runes are created if the conversion rules are satisfied. Any remaining runes post-conversion are transferred to the ID of the last edict in the runestone.</p>
<h2 id="cenotaphs"><a class="header" href="#cenotaphs">Cenotaphs</a></h2>
<p>Runestones may be malformed for a number of reasons, including non-pushdata opcodes in the runestone <code>OP_RETURN</code>, invalid varints, or unrecognized runestone fields.</p>
<p>Malformed runestones are termed <a href="https://en.wikipedia.org/wiki/Cenotaph">cenotaphs</a>.</p>
<p>Runes input to a transaction with a cenotaph are burned. Runes etched in a transaction with a cenotaph are set as unmintable. Mints in a transaction with a cenotaph count towards the mint cap, but the minted runes are burned.</p>
<p>Cenotaphs are an upgrade mechanism, allowing runestones to be given new semantics that change how runes are created and transferred, while not misleading unupgraded clients as to the location of those runes, as unupgraded clients will see those runes as having been burned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitomc-does-not-have-a-specification"><a class="header" href="#bitomc-does-not-have-a-specification">BitOMC Does Not Have a Specification</a></h1>
<p>The BitOMC reference implementation, <code>bitomc</code>, is the normative specification of the BitOMC protocol.</p>
<p>Nothing you read here or elsewhere, aside from the code of <code>bitomc</code>, is a specification. This prose description of the BitOMC protocol is provided as a guide to the behavior of <code>bitomc</code>, and the code of <code>bitomc</code> itself should always be consulted to confirm the correctness of any prose description.</p>
<p>If, due to a bug in <code>bitomc</code>, this document diverges from the actual behavior of <code>bitomc</code> and it is impractically disruptive to change <code>bitomc</code>'s behavior, this document will be amended to agree with <code>bitomc</code>'s actual behavior.</p>
<p>Users of alternative implementations do so at their own risk, and services wishing to integrate Runes are strongly encouraged to use <code>bitomc</code> itself to make Runes transactions, and to determine the state of runes, mints, and balances.</p>
<h2 id="runestones-1"><a class="header" href="#runestones-1">Runestones</a></h2>
<p>Like Runes, BitOMC protocol messages are termed "runestones".</p>
<p>The protocol activates on block 855,000. Runestones in earlier blocks are ignored.</p>
<p>Abstractly, runestones contain the following fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Runestone {
  edicts: Vec&lt;Edict&gt;,
  pointer: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Runes are transferred by edict:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Edict {
  id: RuneId,
  amount: u128,
  output: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>Rune IDs are encoded as the block height and transaction index of the transaction in which the rune was etched:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RuneId {
  block: u64,
  tx: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>Rune IDs are represented in text as <code>BLOCK:TX</code>.</p>
<p>Rune names are encoded as modified base-26 integers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rune(u128);
<span class="boring">}</span></code></pre></pre>
<h3 id="deciphering"><a class="header" href="#deciphering">Deciphering</a></h3>
<p>Runestones are deciphered from transactions with the following steps:</p>
<ol>
<li>
<p>Find the first transaction output whose script pubkey begins with <code>OP_RETURN OP_14</code>.</p>
</li>
<li>
<p>Concatenate all following data pushes into a payload buffer.</p>
</li>
<li>
<p>Decode a sequence 128-bit <a href="https://en.wikipedia.org/wiki/LEB128">LEB128</a> integers from the payload buffer.</p>
</li>
<li>
<p>Parse the sequence of integers into an untyped message.</p>
</li>
<li>
<p>Parse the untyped message into a runestone.</p>
</li>
</ol>
<p>Deciphering may produce a malformed runestone, termed a <a href="https://en.wikipedia.org/wiki/Cenotaph">cenotaph</a>.</p>
<h4 id="locating-the-runestone-output"><a class="header" href="#locating-the-runestone-output">Locating the Runestone Output</a></h4>
<p>Outputs are searched for the first script pubkey that beings with <code>OP_RETURN OP_14</code>. If deciphering fails, later matching outputs are not considered.</p>
<h4 id="assembling-the-payload-buffer"><a class="header" href="#assembling-the-payload-buffer">Assembling the Payload Buffer</a></h4>
<p>The payload buffer is assembled by concatenating data pushes, after <code>OP_14</code>, in the matching script pubkey.</p>
<p>Data pushes are opcodes 0 through 78 inclusive. If a non-data push opcode is encountered, i.e., any opcode equal to or greater than opcode 79, the deciphered runestone is a cenotaph with no etching, mint, or edicts.</p>
<h4 id="decoding-the-integer-sequence"><a class="header" href="#decoding-the-integer-sequence">Decoding the Integer Sequence</a></h4>
<p>A sequence of 128-bit integers are decoded from the payload as LEB128 varints.</p>
<p>LEB128 varints are encoded as sequence of bytes, each of which has the most-significant bit set, except for the last.</p>
<p>If a LEB128 varint contains more than 18 bytes, would overflow a u128, or is truncated, meaning that the end of the payload buffer is reached before encountering a byte with the continuation bit not set, the decoded runestone is a cenotaph with no etching, mint, or edicts.</p>
<h4 id="parsing-the-message"><a class="header" href="#parsing-the-message">Parsing the Message</a></h4>
<p>The integer sequence is parsed into an untyped message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Message {
  pointer: Option&lt;u32&gt;,
  edicts: Vec&lt;Edict&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>If the number of integers is odd, the first integer is interpreted as the pointer, and all subsequent integer pairs are interpreted as edicts. If the number of integers is even, the pointer is set to null, and each integer pair is interpreted as an edict.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Edict {
  id: RuneId,
  amount: u128,
  output: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>In the integer pair, <code>id</code> is interpreted as <code>1:0</code> (Tighten) if the first integer is even. Otherwise, <code>id</code> is interpreted as <code>1:1</code> (Ease). <code>amount</code> is interpreted as the first integer divided by 2, and <code>output</code> is interpreted as the second integer.</p>
<h4 id="minting-1"><a class="header" href="#minting-1">Minting</a></h4>
<p>A transaction may mint Tighten and Ease by including an output that anyone can spend after 1 block, using a P2WSH for <code>OP_1 OP_CHECKSEQUENCEVERIFY</code>, and spending the output of the previous mint, if unspent. If no such output exists, the first mint transaction receives the mint reward.</p>
<p>If successful, the mint amount is added to the unallocated runes in the transaction's inputs. These runes may be transferred using edicts, and will otherwise be transferred to the first non-<code>OP_RETURN</code> output, or the output designated by the <code>Pointer</code> field. A runestone is required for a mint transaction to be valid.</p>
<p>At the start of each block, the amount of Tighten and Ease to be issued is immediately burned, and the mint transaction receives the amount of outstanding burned Tighten and Ease. For this reason, if no mint transaction is present, the runes to be issued are made available to the first minter in subsequent blocks.</p>
<h4 id="transferring-1"><a class="header" href="#transferring-1">Transferring</a></h4>
<p>Runes are transferred by edict:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Edict {
  id: RuneId,
  amount: u128,
  output: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>A runestone may contain any number of edicts, which are processed in sequence.</p>
<p>Before edicts are processed, input runes, as well as minted or premined runes, if any, are unallocated.</p>
<p>Each edict decrements the unallocated balance of rune <code>id</code> and increments the balance allocated to transaction outputs of rune <code>id</code>.</p>
<p>If an edict would allocate more runes than are currently unallocated, the <code>amount</code> is reduced to the number of currently unallocated runes. In other words, the edict allocates all remaining unallocated units of rune <code>id</code>.</p>
<p>An edict with <code>amount</code> zero allocates all remaining units of rune <code>id</code>.</p>
<p>An edict with <code>output</code> equal to the number of transaction outputs allocates <code>amount</code> runes to each non-<code>OP_RETURN</code> output in order.</p>
<p>An edict with <code>amount</code> zero and <code>output</code> equal to the number of transaction outputs divides all unallocated units of rune <code>id</code> between each non-<code>OP_RETURN</code> output. If the number of unallocated runes is not divisible by the number of non-<code>OP_RETURN</code> outputs, 1 additional rune is assigned to the first <code>R</code> non-<code>OP_RETURN</code> outputs, where <code>R</code> is the remainder after dividing the balance of unallocated units of rune <code>id</code> by the number of non-<code>OP_RETURN</code> outputs.</p>
<p>If any edict in a runestone has an <code>output</code> greater than the number of transaction outputs, the runestone is a cenotaph.</p>
<p>Note that edicts in cenotaphs are not processed, and all input runes are burned.</p>
<h4 id="converting-1"><a class="header" href="#converting-1">Converting</a></h4>
<p>A runestone may convert between Tighten and Ease by burning one as an input and allocating more of the other than are unallocated. The ID of the final edict in the Runestone determines whether the input or the output of the conversion is to be exact. If the ID is the same as the output ID, then the input is exact and the required output is the minimum allowable output amount. Otherwise, the output is exact and the input is the maximum allowable input amount.</p>
<p>Runes are converted according to the invariant <code>A^2 + B^2 = K^2</code>, where <code>A</code> and <code>B</code> are the supply of Tighten and Ease, respectively, and <code>K</code> is some constant, which is the same before and after.</p>
<p>If the invariant is satisfied, the output runes are allocated. If the conversion yields more output runes than the minimum allowable output amount, the additional output runes are allocated to the first tx output already receiving output runes.</p>
<p>If the conversion requires fewer input runes than the maximum allowable input amount, the leftover input runes are allocated to the output of the last edict of input ID with an output whose value is less than the number of tx outputs. If no such output exists, the input runes are allocated to the first output with a non-zero balance for input ID. If still unallocated, the input runes are allocated to the output of the first edict.</p>
<p>If the invariant is not satisfied, the transaction does not signal RBF, the transaction fails to leave a P2WPKH output for the private key <code>0x01</code> repeating, or the P2WPKH output of the preceding conversion is unspent and not spent by this transaction, the burned input runes are unburned and allocated according to the same rules as the preceding paragraph.</p>
<p>An exception to this final condition is made for conversions in a block <code>P</code> in which the first conversion cannot spend an output of a previous conversion. When this is case, conversions in the block do not need to spend an output of the previous conversion to be valid. The first conversion in the next block, however, must spend the output created by the first conversion in block <code>P</code>.</p>
<h2 id="the-util"><a class="header" href="#the-util">The Util</a></h2>
<p>The util is the dynamic unit of account created by BitOMC. The util is a dynamic sub-denomination of sats, determined by an interest rate that is controlled by the relative quantity of Tighten and Ease. To calculate the number of utils per sat, a second sub-denomination of sats is introduced, called the e-bond. The number of e-bonds per sat increases monotically at the current interest rate. The number of utils per sat is then determined by the number of utils per e-bond, which is 1 divided by the interest rate.</p>
<h3 id="the-interest-rate"><a class="header" href="#the-interest-rate">The Interest Rate</a></h3>
<p>The interest rate equals the median value of <code>(A - B) / (A + B)</code> over the last 100 blocks where <code>A &gt; B</code> and <code>(A - B) / (A + B)</code> is non-zero after integer division. <code>A</code> and <code>B</code> are the supply of Tighten and Ease, respectively, and the value is calculated to 12 decimal places. The default interest rate is 100%.</p>
<p>The number of e-bonds per sat is stored as an integer with 12 decimal places and updated each block using the current interest rate divided by 52,595, which is approximately the number of blocks per year.</p>
<h3 id="utils-per-sat"><a class="header" href="#utils-per-sat">Utils per Sat</a></h3>
<p>The number of utils per bond is calculated by dividing 10^24 by the interest rate in integer form.</p>
<p>The number of utils per sat is calculated by multiplying the number of bonds per sat by the number of utils per bond and dividing by 10^12.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mag-ambag-sa-bitomc"><a class="header" href="#mag-ambag-sa-bitomc">Mag-ambag sa <code>bitomc</code></a></h1>
<h2 id="mga-iminungkahing-hakbang"><a class="header" href="#mga-iminungkahing-hakbang">Mga iminungkahing hakbang</a></h2>
<ol>
<li>Maghanap ng isyu na gusto mong ayusin.</li>
<li>Tukuyin kung ano ang magiging magandang unang hakbang patungo sa paglutas ng isyu. Ito ay maaaring nasa anyo ng code, pananaliksik, panukala, o sa pamamagitan ng pagmumungkahi na i-close ito, kung ito ay lipas na o hindi magandang ideya sa simula pa lang.</li>
<li>Magkomento sa problema, at humihingi ng feedback. Maaari kang sumali at magsimulang magsulat ng code o mag test, ngunit nakakatipid sa oras ang pagberipika kung ang paksa ay luma na, kung hindi ito malinaw, kung ito ay hindi pa handang ipatupad.</li>
<li>Kung ang isyu ay nangangailangan ng pagbabago ng code o pag-aayos sa isang bug, magbukas ng PR (pull request) draft na may kasamang test, at humingi ng feedback. Nakakatulong ito na matiyak na ang lahat ay sumasang-ayon sa kung ano ang kailangang gawin o ang unang hakbang sa paglutas ng problema. Dapat tandaan na ang paggawa ng tests at mahalaga upang madali at mabilis ma peripika ang iyong PR.</li>
<li>Gumawa ng maraming test, at i-tweak ang code hanggang sa handa na itong isumite.</li>
<li>Markahan ang PR ng “ready to review”.</li>
<li>Baguhin ang PR kung kinakailangan.</li>
<li>At sa huli, maari itong mai-merge!</li>
</ol>
<h2 id="magsimula-sa-maliit"><a class="header" href="#magsimula-sa-maliit">Magsimula sa maliit</a></h2>
<p>Ang mga maliliit pagbabago ay magbibigay-daan sayo na makapag-ambag ng mabilis, at kung hindi, hindi ka mag-aaksaya ng maraming oras.</p>
<p>Mga ideya:</p>
<ul>
<li>Magdagdag ng bagong test o test cases</li>
<li>Magdagdag o pagbutihin ang dokumentasyon</li>
<li>Maghanap ng isyu na nangangailangan ng higit pang pananaliksik, gawin ang pagsasaliksik na iyon, at ibuod ito sa isang komento.</li>
<li>Maghanap ng out-of-date na isyu.</li>
<li>Maghanap ng isyu na hindi dapat gawin, at magbigay ng constructive na feedback na nagdedetalye kung bakit sa tingin mo ay ganito ang sitwasyon.</li>
</ul>
<h2 id="mag-merge-nang-maaga-at-madalas"><a class="header" href="#mag-merge-nang-maaga-at-madalas">Mag-merge nang maaga at madalas</a></h2>
<p>Hatiin ang malalaking gawain sa mas maliliit na hakbang. Kung mayroong isang bug, maaari kang magbukas ng PR na nagdaragdag ng isang failing ignored test. Maaari itong i-merge, at ang susunod na hakbang ay ang pag-ayos ng bug at karagdagang tests. Magsagawa ng pananaliksik o pag-testing, at iulat ang iyong mga resulta. Hatiin ang isang feature sa maliliit na sub-feature at isa-isang i-fix ang mga ito.</p>
<p>Ang paghahanap ng paraan upang hatiin ang isang malaking PR sa mas maliliit na PR ay isang form of art na magandang practice bilang isang contributor. Ang mahirap na bahagi ay ang bawat PR ay dapat na isang improvement.</p>
<p>Sinisikap kong sundin ang payo na ito sa aking sarili, at palaging mas maganda kapag ginagawa ko.</p>
<p>Ang mga maliliit na changes ay mabilis na bumalangkas, nagre-rebisa, at nagsasama, na mas maganda kaysa sa pagtatrabaho sa isang malaking PR na tumatagal nang walang hanggan sa pag-draft, pagbabago, at pagsasama. Ang maliliit na changes ay hindi tumatagal ng maraming oras, kaya kung kailangan mong huminto sa paggawa sa isang maliit na changes, hindi ka magsasayang ng maraming oras kumpara sa isang mas malaking changes. Ang mabilis pag-PR ay nakakatulong na mapabuti ang proyekto kaagad, imbes na maghintay ng mahabang panahon para sa mas malaking changes. Ang maliliit na changes ay mas malamang na magdulot kakaunting conflict sa pagme-merge. Gaya ng sinabi ng mga taga-Athenians: <em>The fast commit what they will, the slow merge what they must.</em></p>
<h2 id="humingi-ng-tulong"><a class="header" href="#humingi-ng-tulong">Humingi ng tulong</a></h2>
<p>Kung natigil ka nang higit sa 15 minuto, humingi ng tulong, halimbawa sa Rust Discord, Stack Exchange, o sa project issue or discussion board.</p>
<h2 id="i-practice-ang-hypothesis-driven-debugging"><a class="header" href="#i-practice-ang-hypothesis-driven-debugging">I-practice ang hypothesis-driven debugging</a></h2>
<p>Bumuo ng hypothesis tungkol sa sanhi ng problema. Alamin kung paano i-test ang hypothesis na ito. Gawin ang test na ito. Kung ito ay gumana, maaari mong malutas ang problema o ngayon alam kung paano ayusin ito. Kung hindi, magsimulang muli sa isang bagong hypothesis.</p>
<h2 id="bigyang-pansin-ang-mga-mensahe-ng-error"><a class="header" href="#bigyang-pansin-ang-mga-mensahe-ng-error">Bigyang-pansin ang mga mensahe ng error</a></h2>
<p>Basahin ang lahat ng mga mensahe ng error at huwag i-tolerate ang mga warnings.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitomc-guides"><a class="header" href="#bitomc-guides">BitOMC Guides</a></h1>
<p>See the table of contents for a list of guides, including a guide to the explorer and a guide to the wallet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet"><a class="header" href="#wallet">Wallet</a></h1>
<p>Tighten and Ease can be held in a Bitcoin wallet and transferred using Bitcoin transactions. Utils are a floating denomination of sats and can be transferred by transferring the equivalent number of sats.</p>
<p>BitOMC requires a Bitcoin node to give you a view of the current state of the Bitcoin blockchain, and a wallet that can transfer utils, mint and convert Tighten and Ease, and perform sat control when constructing transactions to send them to another wallet.</p>
<p>Bitcoin Core provides both a Bitcoin node and wallet. However, the Bitcoin Core wallet cannot mint or convert Tighten and Ease and does not perform sat control.</p>
<p>The utility <a href="https://github.com/BitOMC/BitOMC"><code>bitomc</code></a> doesn't implement its own wallet, so <code>bitomc wallet</code> subcommands interact with Bitcoin Core wallets.</p>
<p>Sinasaklaw ng gabay na ito ang mga sumusunod na punto:</p>
<ol>
<li>Pag-install ng Bitcoin Core</li>
<li>Pag-synchronize ng Bitcoin Blockchain</li>
<li>Gumawa ng Bitcoin Core wallet</li>
<li>Gamitin ang <code>bitomc wallet receive</code> para makatanggap ng sats</li>
<li>Minting Tighten and Ease with <code>bitomc wallet mint</code></li>
<li>Converting Tighten and Ease with <code>bitomc wallet convert-exact-input</code> and <code>bitomc wallet convert-exact-output</code></li>
<li>Sending sats, utils, and Tighten and Ease with <code>bitomc wallet send</code></li>
<li>Receiving Tighten and Ease with <code>bitomc wallet receive</code></li>
</ol>
<h2 id="kumuha-ng-tulong"><a class="header" href="#kumuha-ng-tulong">Kumuha ng tulong</a></h2>
<p>Kung natigil ka, subukang humingi ng tulong sa server ng <a href="https://discord.com/invite/87cjuz4FYg">Ordinals Discord</a>, o tingnan ang GitHub para sa mga <a href="https://github.com/BitOMC/BitOMC/issues">isyu</a> at <a href="https://github.com/BitOMC/BitOMC/discussions">discussions</a>.</p>
<h2 id="pag-install-ng-bitcoin-core"><a class="header" href="#pag-install-ng-bitcoin-core">Pag-install ng Bitcoin Core</a></h2>
<p>Ang Bitcoin Core ay mada-download sa <a href="https://bitcoincore.org/">bitcoincore.org</a> sa pahina ng <a href="https://bitcoincore.org/en/download/">pag-download</a>.</p>
<p><code>bitomc</code> requires Bitcoin Core 24 or newer.</p>
<p>Hindi saklaw ng gabay na ito ang pag-install ng Bitcoin Core nang detalyado. Kapag na-install na ang Bitcoin Core, dapat ay matagumpay mong mapatakbo ang <code>bitcoind -version</code> mula sa command line. <em>HUWAG</em> gamitin ang <code>bitcoin-qt</code>.</p>
<h2 id="bitcoin-core-setup"><a class="header" href="#bitcoin-core-setup">Bitcoin Core Setup</a></h2>
<p><code>bitomc</code> requires Bitcoin Core's rest interface and block data. The <code>bitomc</code> explorer also requires the transaction index, but the explorer is optional.</p>
<p>I-configure ang iyong Bitcoin Core node upang mapanatili ang index ng mga transaksyon, idagdag ang sumusunod sa iyong bitcoin.conf file:</p>
<pre><code>txindex=1
</code></pre>
<p>O, patakbuhin ang <code>bitcoind</code> gamit ang <code>-txindex</code>:</p>
<pre><code>bitcoind -txindex
</code></pre>
<p><code>bitomc</code> can be run on a Bitcoin Core node pruned below block 855000. Subsequent blocks can be manually pruned after being indexed by <code>bitomc</code>, but doing so will prevent <code>bitomc</code> from re-indexing.</p>
<p>Ang mga detalye sa paggawa o pagbabago ng iyong <code>bitcoin.conf</code> na file ay matatagpuan <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/bitcoin-conf.md">dito</a>.</p>
<h2 id="pag-synchronize-ng-bitcoin-blockchain"><a class="header" href="#pag-synchronize-ng-bitcoin-blockchain">Pag-synchronize ng Bitcoin Blockchain</a></h2>
<p>Upang i-sync ang blockchain patakbuhin ang sumusunod na command</p>
<pre><code>bitcoind
</code></pre>
<p>…at hayaan itong tumakbo hanggang sa <code>getblockcount</code>:</p>
<pre><code>bitcoin-cli getblockcount
</code></pre>
<p>tumutugma sa bilang ng mga bloke tulad nalamang ng <a href="https://mempool.space/">mempool.space block explorer</a>. Nakikipag-ugnayan ang <code>bitomc</code> sa <code>bitcoind</code>, kaya dapat mong iwanan ang <code>bitcoind</code> na tumatakbo sa background kapag gumagamit ng <code>bitomc</code>.</p>
<p>Ang blockchain ay humigit-kumulang 600GB disk space. Kung mayroon kang external drive na gamitin para mag-store ng blocks, gamitin ang configuration option <code>blocksdir=&lt;external_drive_path&gt;</code>. Ito ay mas simple kaysa sa paggamit ng <code>datadir</code> na opsyon dahil ang cookie file ay nasa default pa ring lokasyon para mahanap ang <code>bitcoin-cli</code> at <code>bitomc</code>.</p>
<h2 id="pag-troubleshoot"><a class="header" href="#pag-troubleshoot">Pag-Troubleshoot</a></h2>
<p>Tiyaking maa-access mo ang <code>bitcoind</code> gamit ang <code>bitcoin-cli -getinfo</code> at ito ay ay ganap na naka-sync.</p>
<p>Kung ibabalik ng <code>bitcoin-cli -getinfo</code> ang <code>Could not connect to the server</code>, Hindi tumatakbo ang iyong <code>bitcoind</code>.</p>
<p>Tiyaking <code>rpcuser</code>, <code>rpcpassword</code>, o <code>rpcauth</code> ay <em>HINDI</em> naka-set sa iyong <code>bitcoin.conf</code> file. Ang <code>bitomc</code> ay nangangailangan ng paggamit ng cookie authentication. Tiyaking may file na <code>.cookie</code> sa iyong bitcoin data directory.</p>
<p>Kung ibabalik ng <code>bitcoin-cli -getinfo</code> ang <code>Could not locate RPC credentials</code>, kung gayon dapat mong tukuyin ang lokasyon ng cookie file. Kung gumagamit ka ng custom na data directory (tumutukoy sa <code>datadir</code>), dapat mong tukuyin ang lokasyon ng cookie tulad ng <code>bitcoin-cli -rpccookiefile=&lt;your_bitcoin_datadir&gt;/.cookie -getinfo</code>. Kapag nagpapatakbo ng <code>bitomc</code> dapat mong tukuyin ang cookie file location na may <code>--cookie-file=&lt;your_bitcoin_datadir&gt;/.cookie</code>.</p>
<p>Tiyaking <em>WALA</em> kang <code>disablewallet=1</code> sa iyong <code>bitcoin.conf</code> file.Kung ibabalik ng <code>bitcoin-cli listwallet</code> ang <code>Method not found</code> ang wallet ay naka-disable at hindi mo magagamit ang <code>bitomc</code>.</p>
<p>Kung mayroon kang naka-set na <code>maxuploadtarget</code> maaari itong makagambala sa pagkuha ng mga bloke para sa index ng <code>bitomc</code>. Alisin ito o i-set ang <code>whitebind=127.0.0.1:8333</code>.</p>
<h2 id="pag-install-ng-bitomc"><a class="header" href="#pag-install-ng-bitomc">Pag-install ng <code>bitomc</code></a></h2>
<p>Ang <code>bitomc</code> utility ay nakasulat sa Rust at maaaring i-compile mula sa <a href="https://github.com/BitOMC/BitOMC">source</a>. Available ang mga pre-built na binary sa page ng mga <a href="https://github.com/BitOMC/BitOMC/releases">release page</a>.</p>
<p>Maaari mong i-install ang pinakabagong prebuilt binary mula sa command line gamit ang:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -fsLS https://bitomc.org/install.sh | bash -s
</code></pre>
<p>Kapag na-install na ang bitomc, dapat mong patakbuhin ang:</p>
<pre><code>bitomc --version
</code></pre>
<p>na magpapakita ng numero ng bersyon ng <code>bitomc</code>.</p>
<h2 id="creating-a-wallet"><a class="header" href="#creating-a-wallet">Creating a Wallet</a></h2>
<p><code>bitomc</code> uses <code>bitcoind</code> to manage private keys, sign transactions, and broadcast transactions to the Bitcoin network. Additionally the <code>bitomc wallet</code> requires <code>bitomc server</code> running in the background. Make sure these programs are running:</p>
<pre><code>bitcoind
</code></pre>
<pre><code>bitomc server
</code></pre>
<p>To create a wallet named <code>bitomc</code>, the default, for use with <code>bitomc wallet</code>, run:</p>
<pre><code>bitomc wallet create
</code></pre>
<p>This will print out your seed phrase mnemonic, store it somewhere safe.</p>
<pre><code>{
  "mnemonic": "dignity buddy actor toast talk crisp city annual tourist orient similar federal",
  "passphrase": ""
}
</code></pre>
<p>If you want to specify a different name or use an <code>bitomc server</code> running on a non-default URL you can set these options:</p>
<pre><code>bitomc wallet --name foo --server-url http://127.0.0.1:8080 create
</code></pre>
<p>To see all available wallet options you can run:</p>
<pre><code>bitomc wallet help
</code></pre>
<h2 id="restoring-and-dumping-wallet"><a class="header" href="#restoring-and-dumping-wallet">Restoring and Dumping Wallet</a></h2>
<p>The <code>bitomc</code> wallet uses descriptors, so you can export the output descriptors and import them into another descriptor-based wallet. To export the wallet descriptors, which include your private keys:</p>
<pre><code>$ bitomc wallet dump
==========================================
= THIS STRING CONTAINS YOUR PRIVATE KEYS =
=        DO NOT SHARE WITH ANYONE        =
==========================================
{
  "wallet_name": "bitomc",
  "descriptors": [
    {
      "desc": "tr([551ac972/86'/1'/0']tprv8h4xBhrfZwX9o1XtUMmz92yNiGRYjF9B1vkvQ858aN1UQcACZNqN9nFzj3vrYPa4jdPMfw4ooMuNBfR4gcYm7LmhKZNTaF4etbN29Tj7UcH/0/*)#uxn94yt5",
      "timestamp": 1296688602,
      "active": true,
      "internal": false,
      "range": [
        0,
        999
      ],
      "next": 0
    },
    {
      "desc": "tr([551ac972/86'/1'/0']tprv8h4xBhrfZwX9o1XtUMmz92yNiGRYjF9B1vkvQ858aN1UQcACZNqN9nFzj3vrYPa4jdPMfw4ooMuNBfR4gcYm7LmhKZNTaF4etbN29Tj7UcH/1/*)#djkyg3mv",
      "timestamp": 1296688602,
      "active": true,
      "internal": true,
      "range": [
        0,
        999
      ],
      "next": 0
    }
  ]
}
</code></pre>
<p>An <code>bitomc</code> wallet can be restored from a mnemonic:</p>
<pre><code>bitomc wallet restore --from mnemonic
</code></pre>
<p>Type your mnemonic and press return.</p>
<p>To restore from a descriptor in <code>descriptor.json</code>:</p>
<pre><code>cat descriptor.json | bitomc wallet restore --from descriptor
</code></pre>
<p>To restore from a descriptor in the clipboard:</p>
<pre><code>bitomc wallet restore --from descriptor
</code></pre>
<p>Paste the descriptor into the terminal and press CTRL-D on unix and CTRL-Z on Windows.</p>
<h2 id="tumanggap-ng-sats"><a class="header" href="#tumanggap-ng-sats">Tumanggap ng sats</a></h2>
<p>Ang mga inscription ay ginagawa sa mga indibidwal na sats, gamit ang mga normal na transaksyon sa Bitcoin na nagbabayad ng gamit ang sats, kaya ang iyong wallet ay mangangailangan ng mga sats.</p>
<p>Kumuha ng bagong address mula sa iyong bitomc wallet sa pamamagitan ng:</p>
<pre><code>bitomc wallet receive
</code></pre>
<p>At magpadala ng pondo.</p>
<p>Maaari mong tingnan ang mga kasalukuyang transaksyon gamit ang:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Kapag nakumpirma na ang transaksyon, dapat mong makita ang mga resulta ng transaksyon sa mga<code>bitomc wallet outputs</code>.</p>
<h2 id="minting-tighten-and-ease"><a class="header" href="#minting-tighten-and-ease">Minting Tighten and Ease</a></h2>
<p>To mint Tighten and Ease, run:</p>
<pre><code>bitomc wallet mint --fee-rate &lt;FEE_RATE&gt;
</code></pre>
<p>BitOMC will output the transaction ID, the amount of Tighten and Ease received, and a <code>connected</code> boolean, which will be <code>true</code> if the transaction spends the output left by the previous mint transaction. If so, the transaction will be added to the mempool if and only if it is able to RBF the existing candidate mint transaction (or if it is the first mint transaction seen). If <code>false</code>, the transaction will only mint Tighten and Ease if it is the first transaction in the block.</p>
<p>You can check the status of the transactions using <a href="https://mempool.space/">the mempool.space block explorer</a>.</p>
<p>Once the transaction has been mined, you can confirm receipt by running:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="converting-tighten-and-ease"><a class="header" href="#converting-tighten-and-ease">Converting Tighten and Ease</a></h2>
<p>To convert between Tighten and Ease using an exact input amount, run:</p>
<pre><code>bitomc wallet convert-exact-input --fee-rate &lt;INPUT_AMOUNT&gt; &lt;MIN_OUTPUT_AMOUNT&gt;
</code></pre>
<p>Where <code>INPUT_AMOUNT</code> is the number of runes to convert, a <code>:</code> character, and the name of the input rune, and <code>MIN_OUTPUT_AMOUNT</code> is the minimum number of runes you wish to receive, a <code>:</code> character, and the name of the output rune.</p>
<p>For example, if you want to convert 1000 TIGHTEN and receive at least 500 EASE, you would use <code>1000:TIGHTEN</code> and <code>500:EASE</code>.</p>
<pre><code>bitomc wallet convert-exact-input --fee-rate 1 1000:TIGHTEN 500:EASE
</code></pre>
<p>Alternatively, if you want to convert 1000 TIGHTEN at the latest conversion rate, you would use <code>1000:TIGHTEN</code> and <code>0:EASE</code>.</p>
<pre><code>bitomc wallet convert-exact-input --fee-rate 1 1000:TIGHTEN 0:EASE
</code></pre>
<p>To convert between Tighten and Ease using an exact output amount, run:</p>
<pre><code>bitomc wallet convert-exact-input --fee-rate &lt;OUTPUT_AMOUNT&gt; &lt;MAX_INPUT_AMOUNT&gt;
</code></pre>
<p>BitOMC will output the transaction ID, the expected amount of Tighten and Ease received, and a <code>connected</code> boolean, which will be <code>true</code> if and only if the transaction spends the output left by the preceding conversion transaction.</p>
<p>You can check the status of the transactions using <a href="https://mempool.space/">the mempool.space block explorer</a>.</p>
<p>Once the transaction has been mined, you can confirm receipt by running:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="sending-sats"><a class="header" href="#sending-sats">Sending Sats</a></h2>
<p>Send sats by running:</p>
<pre><code>bitomc wallet send --fee-rate &lt;FEE_RATE&gt; &lt;ADDRESS&gt; &lt;SAT_AMOUNT&gt;
</code></pre>
<p>Where <code>SAT_AMOUNT</code> is the amount of sats to send, an optional space, and the denomination (<code>bit|btc|cbtc|mbtc|msat|nbtc|pbtc|sat|satoshi|ubtc</code>). For example if you want to send 1000 sats, you would use <code>1000 sats</code>.</p>
<pre><code>bitomc wallet send --fee-rate 1 SOME_ADDRESS 1000 sats
</code></pre>
<p>Tingnan ang mga pending na transaction gamit ang:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Kapag nakumpirma na ang transaksyon sa pagpapadala, maaaring kumpirmahin ng tatanggap sa pamamagitan ng:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="sending-utils"><a class="header" href="#sending-utils">Sending Utils</a></h2>
<p>Send utils by running:</p>
<pre><code>bitomc wallet send --fee-rate &lt;FEE_RATE&gt; &lt;ADDRESS&gt; &lt;UTIL_AMOUNT&gt;
</code></pre>
<p>Where <code>UTIL_AMOUNT</code> is the amount of sats to send, an optional space, and the denomination <code>util</code> or <code>utils</code>. For example if you want to send 1000 utils, you would use <code>1000 utils</code>.</p>
<pre><code>bitomc wallet send --fee-rate 1 SOME_ADDRESS 1000 utils
</code></pre>
<p>Tingnan ang mga pending na transaction gamit ang:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Kapag nakumpirma na ang transaksyon sa pagpapadala, maaaring kumpirmahin ng tatanggap sa pamamagitan ng:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="sending-tighten-and-ease"><a class="header" href="#sending-tighten-and-ease">Sending Tighten and Ease</a></h2>
<p>Mag-generate ng bagong address gamit ang:</p>
<pre><code>bitomc wallet receive
</code></pre>
<p>Send the runes by running:</p>
<pre><code>bitomc wallet send --fee-rate &lt;FEE_RATE&gt; &lt;ADDRESS&gt; &lt;RUNES_AMOUNT&gt;
</code></pre>
<p>Where <code>RUNES_AMOUNT</code> is the number of runes to send, a <code>:</code> character, and the name of the rune. For example if you want to send 1000 of TIGHTEN, you would use <code>1000:TIGHTEN</code>.</p>
<pre><code>bitomc wallet send --fee-rate 1 SOME_ADDRESS 1000:EXAMPLE
</code></pre>
<p>Likewise, if you want to send 1000 of EASE, you would use <code>1000:EASE</code>.</p>
<pre><code>bitomc wallet send --fee-rate 1 SOME_ADDRESS 1000:EASE
</code></pre>
<p>Tingnan ang mga pending na transaction gamit ang:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Once the send transaction confirms, the recipient can confirm receipt with:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="receiving-runes"><a class="header" href="#receiving-runes">Receiving Runes</a></h2>
<p>Bumuo ng bagong address sa pagtanggap gamit ang:</p>
<pre><code>bitomc wallet receive
</code></pre>
<p>The sender can transfer the rune to your address using:</p>
<pre><code>bitomc wallet send --fee-rate &lt;FEE_RATE&gt; &lt;ADDRESS&gt; &lt;RUNES_AMOUNT&gt;
</code></pre>
<p>Tingnan ang mga pending na transaction gamit ang:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Once the send transaction confirms, you can confirm receipt by running:</p>
<pre><code>bitomc wallet balance
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reindexing"><a class="header" href="#reindexing">Reindexing</a></h1>
<p>Minsan ang database ng <code>bitomc</code> ay dapat na i-reindex, na nangangahulugan ng pagtanggal ng database at i-restart ang proseso ng pag-index gamit ang alinman sa <code>bitomc index update</code> o <code>bitomc server</code>. Ang mga dahilan para muling i-index ay:</p>
<ol>
<li>Isang bagong pangunahing release ng bitomc, na nagbabago sa scheme ng database</li>
<li>Na-corrupt ang database</li>
</ol>
<p>Ang database na ginagamit ng <code>bitomc</code> ay tinatawag na <a href="https://github.com/cberner/redb">redb</a>, kaya binibigyan namin ang index ng default na pangalan ng file na <code>index.redb</code>. Bilang default, ni-store namin ang file na ito sa iba't ibang lokasyon depende sa iyong operating system.</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Value</th><th>Halimbawa</th></tr></thead><tbody>
<tr><td>Linux</td><td><code>$XDG_DATA_HOME</code>/bitomc or <code>$HOME</code>/.local/share/bitomc</td><td>/home/alice/.local/share/bitomc</td></tr>
<tr><td>macOS</td><td><code>$HOME</code>/Library/Application Support/bitomc</td><td>/Users/Alice/Library/Application Support/bitomc</td></tr>
<tr><td>Windows</td><td><code>{FOLDERID_RoamingAppData}</code>\bitomc</td><td>C:\Users\Alice\AppData\Roaming\bitomc</td></tr>
</tbody></table>
</div>
<p>Kaya para tanggalin ang database at reindex sa MacOS kailangan mong i-run ang sumusunod sa mga commands sa terminal:</p>
<pre><code class="language-bash">rm ~/Library/Application Support/bitomc/index.redb
bitomc index update
</code></pre>
<p>Siyempre maaari mo ring itakda ang lokasyon ng direktoryo ng data sa iyong sarili gamit ang <code>bitomc --datadir &lt;DIR&gt; index update</code> o bigyan ito ng partikular na filename at path na may <code>bitomc --index &lt;FILENAME&gt; index update</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<p><code>bitomc</code> can be configured with the command line, environment variables, a configuration file, and default values.</p>
<p>The command line takes precedence over environment variables, which take precedence over the configuration file, which takes precedence over defaults.</p>
<p>The path to the configuration file can be given with <code>--config &lt;CONFIG_PATH&gt;</code>. <code>bitomc</code> will error if <code>&lt;CONFIG_PATH&gt;</code> doesn't exist.</p>
<p>The path to a directory containing a configuration file name named <code>bitomc.yaml</code> can be given with <code>--config-dir &lt;CONFIG_DIR_PATH&gt;</code> or <code>--datadir &lt;DATA_DIR_PATH&gt;</code> in which case the config path is <code>&lt;CONFIG_DIR_PATH&gt;/bitomc.yaml</code> or <code>&lt;DATA_DIR_PATH&gt;/bitomc.yaml</code>. It is not an error if it does not exist.</p>
<p>If none of <code>--config</code>, <code>--config-dir</code>, or <code>--datadir</code> are given, and a file named <code>bitomc.yaml</code> exists in the default data directory, it will be loaded.</p>
<p>For a setting named <code>--setting-name</code> on the command line, the environment variable will be named <code>BITOMC_SETTING_NAME</code>, and the config file field will be named <code>setting_name</code>. For example, the data directory can be configured with <code>--datadir</code> on the command line, the <code>BITOMC_DATA_DIR</code> environment variable, or <code>data_dir</code> in the config file.</p>
<p>See <code>bitomc --help</code> for documentation of all the settings.</p>
<p><code>bitomc</code>'s current configuration can be viewed as JSON with the <code>bitomc settings</code> command.</p>
<h2 id="example-configuration"><a class="header" href="#example-configuration">Example Configuration</a></h2>
<pre><code class="language-yaml"># example config

# see `bitomc --help` for setting documentation

bitcoin_data_dir: /var/lib/bitcoin
bitcoin_rpc_password: bar
bitcoin_rpc_url: https://localhost:8000
bitcoin_rpc_username: foo
chain: mainnet
commit_interval: 10000
config: /var/lib/bitomc/bitomc.yaml
config_dir: /var/lib/bitomc
cookie_file: /var/lib/bitcoin/.cookie
data_dir: /var/lib/bitomc
first_rune_height: 100
height_limit: 1000
index: /var/lib/bitomc/index.redb
index_addresses: false
index_cache_size: 1000000000
index_transactions: false
integration_test: true
server_password: bar
server_url: http://localhost:8888
server_username: foo
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pagsuri"><a class="header" href="#pagsuri">Pagsuri</a></h1>
<h2 id="test-environment"><a class="header" href="#test-environment">Test Environment</a></h2>
<p><code>bitomc env &lt;DIRECTORY&gt;</code> creates a test environment in <code>&lt;DIRECTORY&gt;</code>, spins up <code>bitcoind</code> and <code>bitomc server</code> instances, prints example commands for interacting with the test <code>bitcoind</code> and <code>bitomc server</code> instances, waits for <code>CTRL-C</code>, and then shuts down <code>bitcoind</code> and <code>bitomc server</code>.</p>
<p><code>bitomc env</code> tries to use port 9000 for <code>bitcoind</code>'s RPC interface, and port <code>9001</code> for <code>bitomc</code>'s RPC interface, but will fall back to random unused ports.</p>
<p>Inside of the env directory, <code>bitomc env</code> will write <code>bitcoind</code>'s configuration to <code>bitcoin.conf</code>, <code>bitomc</code>'s configuration to <code>bitomc.yaml</code>, and the env configuration to <code>env.json</code>.</p>
<p><code>env.json</code> contains the commands needed to invoke <code>bitcoin-cli</code> and <code>bitomc wallet</code>, as well as the ports <code>bitcoind</code> and <code>bitomc server</code> are listening on.</p>
<p>These can be extracted into shell commands using <code>jq</code>:</p>
<pre><code class="language-shell">bitcoin=`jq -r '.bitcoin_cli_command | join(" ")' env/env.json`
$bitcoin listunspent

bitomc=`jq -r '.ord_wallet_command | join(" ")' env/env.json`
$bitomc outputs
</code></pre>
<p>If <code>bitomc</code> is in the <code>$PATH</code> and the env directory is <code>env</code>, the <code>bitcoin-cli</code> command will be:</p>
<pre><code>bitcoin-cli -datadir=env`
</code></pre>
<p>And the <code>bitomc</code> will be:</p>
<pre><code>bitomc --datadir env
</code></pre>
<h2 id="test-networks"><a class="header" href="#test-networks">Test Networks</a></h2>
<p>BitOMC can be tested using the following flags to specify the test network. For more information on running Bitcoin Core for testing, see <a href="https://developer.bitcoin.org/examples/testing.html">Bitcoin's developer documentation</a>.</p>
<p>Most <code>bitomc</code> commands in <a href="guides/wallet.html">wallet</a> can be run with the following network flags:</p>
<div class="table-wrapper"><table><thead><tr><th>Network</th><th>Flag</th></tr></thead><tbody>
<tr><td>Testnet</td><td><code>--testnet</code> or <code>-t</code></td></tr>
<tr><td>Signet</td><td><code>--signet</code> or <code>-s</code></td></tr>
<tr><td>Regtest</td><td><code>--regtest</code> or <code>-r</code></td></tr>
</tbody></table>
</div>
<p>Regtest doesn't require downloading the blockchain since you create your own private blockchain, so indexing <code>bitomc</code> is almost instantaneous.</p>
<h2 id="halimbawa"><a class="header" href="#halimbawa">Halimbawa</a></h2>
<p>Run <code>bitcoind</code> in regtest with:</p>
<pre><code>bitcoind -regtest -txindex
</code></pre>
<p>Run <code>bitomc server</code> in regtest with:</p>
<pre><code>bitomc --regtest server
</code></pre>
<p>Gumawa ng wallet bilang regtest gamit ang:</p>
<pre><code>bitomc --regtest wallet create
</code></pre>
<p>Kumuha ng isang regtest receive address na may:</p>
<pre><code>bitomc --regtest wallet receive
</code></pre>
<p>Mine 101 blocks (upang i-unlock ang coinbase) gamit ang:</p>
<pre><code>bitcoin-cli -regtest generatetoaddress 101 &lt;receive address&gt;
</code></pre>
<p>Mint in regtest with:</p>
<pre><code>bitomc --regtest wallet mint --fee-rate 1
</code></pre>
<p>Mine the transaction with:</p>
<pre><code>bitcoin-cli -regtest generatetoaddress 1 &lt;receive address&gt;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
