<!DOCTYPE HTML>
<html lang="en" class="coal" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BitOMC Handbook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="language-picker.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "coal";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('coal')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="bitomc.html"><strong aria-hidden="true">2.</strong> BitOMC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bitomc/specification.html"><strong aria-hidden="true">2.1.</strong> Specification</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">3.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="guides.html"><strong aria-hidden="true">4.</strong> Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guides/wallet.html"><strong aria-hidden="true">4.1.</strong> Wallet</a></li><li class="chapter-item expanded "><a href="guides/reindexing.html"><strong aria-hidden="true">4.2.</strong> Reindexing</a></li><li class="chapter-item expanded "><a href="guides/settings.html"><strong aria-hidden="true">4.3.</strong> Settings</a></li><li class="chapter-item expanded "><a href="guides/testing.html"><strong aria-hidden="true">4.4.</strong> Testing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BitOMC Handbook</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="de">Deutsch</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="fr">Français</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="es">Español</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="pt">Português</a>
                          </button></li>
                           <li role="none"><button role="menuitem" class="theme">
                              <a id="ru">Русский</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh">中文版</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ja">日本語版</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ko">한국어</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="fil">Filipino</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ar">العربية</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="hi">हिंदी</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="it">Italiano</a>
                          </button></li>
                        </ul>

                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("en");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BitOMC/BitOMC" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This handbook is a guide to BitOMC, a metaprotocol on Bitcoin that facilitates
the creation of a more stable unit of account for Bitcoin payments.</p>
<p>In a world with ever-changing economic conditions, Bitcoin's fixed supply makes it
unattractive as a unit of account in contracts where payment is due in the future.
BitOMC addresses this by defining a market-driven unit of account that can facilitate
price stability in a Bitcoin economy, without changing Bitcoin's core protocol.</p>
<p>BitOMC uses two interconvertible assets, Tighten and Ease, to establish a dynamic
interest rate and a new unit of Bitcoin called the "util". Tighten and Ease are
transferable on Bitcoin using rules nearly identical to those used by the Runes
protocol.</p>
<p>BitOMC is not premined. Users can mint Tighten and Ease once per block according to
the same four-year halving schedule as Bitcoin. To limit network congestion and MEV,
mint and conversion transactions leave a small anchor output, which must be spent by
the next respective transaction.</p>
<p>For more high-level details, see the <a href="overview.html">overview</a>.</p>
<p>For details on the specification, see <a href="bitomc.html">bitomc</a>.</p>
<p>When you're ready to get your hands dirty, a good place to start is by
<a href="guides/wallet.html">minting</a>.</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://github.com/BitOMC/BitOMC/">GitHub</a></li>
<li><a href="https://bitomc.org/bitomc.pdf">BitOMC Whitepaper</a></li>
<li><a href="https://t.me/bitOMC_chat">BitOMC Telegram group</a></li>
<li><a href="https://bitomc.org/">BitOMC Website</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitomc-overview"><a class="header" href="#bitomc-overview">BitOMC Overview</a></h1>
<p>BitOMC is a fork of the <a href="https://docs.ordinals.com/runes.html">Runes protocol</a>,
consisting of two interconvertible assets, Tighten and Ease, which users can
convert between according to a constant function conversion rule. This keeps
the system in balance and ensures the conversion rate reflects their relative
market price. This conversion rate determines a dynamic interest rate, which in
turn defines a floating unit of Bitcoin called the "util". Transactions continue
to settle in Bitcoin, but parties seeking greater price stability may choose to
denominate their contracts in "utils" rather than BTC or a fiat currency.</p>
<p>Technical details are available in <a href="https://bitomc.org/bitomc.pdf">the whitepaper</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitomc"><a class="header" href="#bitomc">BitOMC</a></h1>
<p>BitOMC is a fork of the <a href="https://docs.ordinals.com/runes.html">Runes protocol</a>.
Runes allow Bitcoin transactions to mint, transfer, and convert Bitcoin-native
digital commodities. There are only two runes in BitOMC, Tighten and Ease.</p>
<h2 id="runestones"><a class="header" href="#runestones">Runestones</a></h2>
<p>Rune protocol messages, called runestones, are stored in Bitcoin transaction
outputs.</p>
<p>In BitOMC, a runestone output's script pubkey begins with an <code>OP_RETURN</code>, followed
by <code>OP_14</code>, followed by zero or more data pushes. These data pushes are
concatenated and decoded into a sequence of 128-bit integers, and finally
parsed into a runestone.</p>
<p>A transaction may have at most one runestone.</p>
<p>A runestone may mint an existing rune, transfer runes from a transaction's inputs
to its outputs, and convert from one rune to another.</p>
<p>A transaction output may hold balances of any number of runes.</p>
<p>Runes are identified by IDs. The IDs of Tighten and Ease are
<code>1:0</code> and <code>1:1</code>, respectively.</p>
<h2 id="minting"><a class="header" href="#minting">Minting</a></h2>
<p>Anyone may create a mint transaction that mints the amount of Tighten and Ease
available in the block the transaction is mined, plus any amount of Tighten and
Ease that has been burned. The issuance of Tighten and Ease follows a four-year
halving schedule as outlined in <a href="https://bitomc.org/bitomc.pdf">the whitepaper</a>.</p>
<h2 id="transferring"><a class="header" href="#transferring">Transferring</a></h2>
<p>When transaction inputs contain runes, or new runes are created by a mint, those
runes are transferred to that transaction's outputs. A transaction's runestone
may change how input runes transfer to outputs.</p>
<h3 id="edicts"><a class="header" href="#edicts">Edicts</a></h3>
<p>A runestone may contain any number of edicts. Edicts consist of a rune ID, an
amount, and an output number. Edicts are processed in order, allocating
unallocated runes to outputs.</p>
<h3 id="pointer"><a class="header" href="#pointer">Pointer</a></h3>
<p>After all edicts are processed, remaining unallocated runes are transferred to
the transaction's first non-<code>OP_RETURN</code> output. A runestone may optionally
contain a pointer that specifies an alternative default output.</p>
<h3 id="burning"><a class="header" href="#burning">Burning</a></h3>
<p>Runes may be burned by transferring them to an <code>OP_RETURN</code> output with an edict
or pointer.</p>
<h2 id="converting"><a class="header" href="#converting">Converting</a></h2>
<p>When runes of one ID are burned and runes of another are transferred in excess
of their input balance, those runes are created if the conversion rules are
satisfied. Any remaining runes post-conversion are transferred to the ID of the
last edict in the runestone.</p>
<h2 id="cenotaphs"><a class="header" href="#cenotaphs">Cenotaphs</a></h2>
<p>Runestones may be malformed for a number of reasons, including non-pushdata
opcodes in the runestone <code>OP_RETURN</code>, invalid varints, or unrecognized
runestone fields.</p>
<p>Malformed runestones are termed
<a href="https://en.wikipedia.org/wiki/Cenotaph">cenotaphs</a>.</p>
<p>Runes input to a transaction with a cenotaph are burned. Runes etched in a
transaction with a cenotaph are set as unmintable. Mints in a transaction with
a cenotaph count towards the mint cap, but the minted runes are burned.</p>
<p>Cenotaphs are an upgrade mechanism, allowing runestones to be given new
semantics that change how runes are created and transferred, while not
misleading unupgraded clients as to the location of those runes, as unupgraded
clients will see those runes as having been burned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitomc-does-not-have-a-specification"><a class="header" href="#bitomc-does-not-have-a-specification">BitOMC Does Not Have a Specification</a></h1>
<p>The BitOMC reference implementation, <code>bitomc</code>, is the normative specification of
the BitOMC protocol.</p>
<p>Nothing you read here or elsewhere, aside from the code of <code>bitomc</code>, is a
specification. This prose description of the BitOMC protocol is provided as a
guide to the behavior of <code>bitomc</code>, and the code of <code>bitomc</code> itself should always be
consulted to confirm the correctness of any prose description.</p>
<p>If, due to a bug in <code>bitomc</code>, this document diverges from the actual behavior of
<code>bitomc</code> and it is impractically disruptive to change <code>bitomc</code>'s behavior, this
document will be amended to agree with <code>bitomc</code>'s actual behavior.</p>
<p>Users of alternative implementations do so at their own risk, and services
wishing to integrate Runes are strongly encouraged to use <code>bitomc</code> itself to make
Runes transactions, and to determine the state of runes, mints, and balances.</p>
<h2 id="runestones-1"><a class="header" href="#runestones-1">Runestones</a></h2>
<p>Like Runes, BitOMC protocol messages are termed "runestones".</p>
<p>The protocol activates on block 854,500. Runestones in earlier blocks are
ignored.</p>
<p>Abstractly, runestones contain the following fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Runestone {
  edicts: Vec&lt;Edict&gt;,
  pointer: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Runes are transferred by edict:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Edict {
  id: RuneId,
  amount: u128,
  output: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>Rune IDs are encoded as the block height and transaction index of the
transaction in which the rune was etched:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RuneId {
  block: u64,
  tx: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>Rune IDs are represented in text as <code>BLOCK:TX</code>.</p>
<p>Rune names are encoded as modified base-26 integers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rune(u128);
<span class="boring">}</span></code></pre></pre>
<h3 id="deciphering"><a class="header" href="#deciphering">Deciphering</a></h3>
<p>Runestones are deciphered from transactions with the following steps:</p>
<ol>
<li>
<p>Find the first transaction output whose script pubkey begins with <code>OP_RETURN OP_14</code>.</p>
</li>
<li>
<p>Concatenate all following data pushes into a payload buffer.</p>
</li>
<li>
<p>Decode a sequence 128-bit <a href="https://en.wikipedia.org/wiki/LEB128">LEB128</a>
integers from the payload buffer.</p>
</li>
<li>
<p>Parse the sequence of integers into an untyped message.</p>
</li>
<li>
<p>Parse the untyped message into a runestone.</p>
</li>
</ol>
<p>Deciphering may produce a malformed runestone, termed a
<a href="https://en.wikipedia.org/wiki/Cenotaph">cenotaph</a>.</p>
<h4 id="locating-the-runestone-output"><a class="header" href="#locating-the-runestone-output">Locating the Runestone Output</a></h4>
<p>Outputs are searched for the first script pubkey that beings with <code>OP_RETURN OP_14</code>. If deciphering fails, later matching outputs are not considered.</p>
<h4 id="assembling-the-payload-buffer"><a class="header" href="#assembling-the-payload-buffer">Assembling the Payload Buffer</a></h4>
<p>The payload buffer is assembled by concatenating data pushes, after <code>OP_14</code>, in
the matching script pubkey.</p>
<p>Data pushes are opcodes 0 through 78 inclusive. If a non-data push opcode is
encountered, i.e., any opcode equal to or greater than opcode 79, the
deciphered runestone is a cenotaph with no etching, mint, or edicts.</p>
<h4 id="decoding-the-integer-sequence"><a class="header" href="#decoding-the-integer-sequence">Decoding the Integer Sequence</a></h4>
<p>A sequence of 128-bit integers are decoded from the payload as LEB128 varints.</p>
<p>LEB128 varints are encoded as sequence of bytes, each of which has the
most-significant bit set, except for the last.</p>
<p>If a LEB128 varint contains more than 18 bytes, would overflow a u128, or is
truncated, meaning that the end of the payload buffer is reached before
encountering a byte with the continuation bit not set, the decoded runestone is
a cenotaph with no etching, mint, or edicts.</p>
<h4 id="parsing-the-message"><a class="header" href="#parsing-the-message">Parsing the Message</a></h4>
<p>The integer sequence is parsed into an untyped message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Message {
  pointer: Option&lt;u32&gt;,
  edicts: Vec&lt;Edict&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>If the number of integers is odd, the first integer is interpreted as the pointer,
and all subsequent integer pairs are interpreted as edicts. If the number of integers
is even, the pointer is set to null, and each integer pair is interpreted as an edict.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Edict {
  id: RuneId,
  amount: u128,
  output: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>In the integer pair, <code>id</code> is interpreted as <code>1:0</code> (Tighten) if the first integer is odd.
Otherwise, <code>id</code> is interpreted as <code>1:1</code> (Ease). <code>amount</code> is interpreted as the first
integer divided by 2, and <code>output</code> is interpreted as the second integer.</p>
<h4 id="minting-1"><a class="header" href="#minting-1">Minting</a></h4>
<p>A transaction may mint Tighten and Ease by including an output that anyone can spend after
1 block, using a P2WSH for <code>OP_1 OP_CHECKSEQUENCEVERIFY</code>, and spending the output of the
previous mint, if unspent. If no such output exists, the first mint transaction receives
the mint reward.</p>
<p>If successful, the mint amount is added to the unallocated runes in the
transaction's inputs. These runes may be transferred using edicts, and will
otherwise be transferred to the first non-<code>OP_RETURN</code> output, or the output
designated by the <code>Pointer</code> field. A runestone is required for a mint transaction
to be valid.</p>
<p>At the start of each block, the amount of Tighten and Ease to be issued is immediately burned,
and the mint transaction receives the amount of outstanding burned Tighten and Ease. For this
reason, if no mint transaction is present, the runes to be issued are made available to
the first minter in subsequent blocks.</p>
<h4 id="transferring-1"><a class="header" href="#transferring-1">Transferring</a></h4>
<p>Runes are transferred by edict:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Edict {
  id: RuneId,
  amount: u128,
  output: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>A runestone may contain any number of edicts, which are processed in sequence.</p>
<p>Before edicts are processed, input runes, as well as minted or premined runes,
if any, are unallocated.</p>
<p>Each edict decrements the unallocated balance of rune <code>id</code> and increments the
balance allocated to transaction outputs of rune <code>id</code>.</p>
<p>If an edict would allocate more runes than are currently unallocated, the
<code>amount</code> is reduced to the number of currently unallocated runes. In other
words, the edict allocates all remaining unallocated units of rune <code>id</code>.</p>
<p>An edict with <code>amount</code> zero allocates all remaining units of rune <code>id</code>.</p>
<p>An edict with <code>output</code> equal to the number of transaction outputs allocates
<code>amount</code> runes to each non-<code>OP_RETURN</code> output in order.</p>
<p>An edict with <code>amount</code> zero and <code>output</code> equal to the number of transaction
outputs divides all unallocated units of rune <code>id</code> between each non-<code>OP_RETURN</code>
output. If the number of unallocated runes is not divisible by the number of
non-<code>OP_RETURN</code> outputs, 1 additional rune is assigned to the first <code>R</code>
non-<code>OP_RETURN</code> outputs, where <code>R</code> is the remainder after dividing the balance
of unallocated units of rune <code>id</code> by the number of non-<code>OP_RETURN</code> outputs.</p>
<p>If any edict in a runestone has an <code>output</code> greater than the number of transaction
outputs, the runestone is a cenotaph.</p>
<p>Note that edicts in cenotaphs are not processed, and all input runes are
burned.</p>
<h4 id="converting-1"><a class="header" href="#converting-1">Converting</a></h4>
<p>A runestone may convert between Tighten and Ease by burning one as an input
and allocating more of the other than are unallocated. The ID of the final edict
in the Runestone determines whether the input or the output of the conversion is
to be exact. If the ID is the same as the output ID, then the input is exact
and the required output is the minimum allowable output amount. Otherwise, the output
is exact and the input is the maximum allowable input amount.</p>
<p>Runes are converted according to the invariant <code>A^2 + B^2 = K^2</code>, where <code>A</code> and
<code>B</code> are the supply of Tighten and Ease, respectively, and <code>K</code> is some constant,
which is the same before and after.</p>
<p>If the invariant is satisfied, the output runes are allocated. If the conversion
yields more output runes than the minimum allowable output amount, the additional
output runes are allocated to the first tx output already receiving output runes.</p>
<p>If the conversion requires fewer input runes than the maximum allowable input amount,
the leftover input runes are allocated to the output of the last edict of input ID
with an output whose value is less than the number of tx outputs. If no such output
exists, the input runes are allocated to the first output with a non-zero balance
for input ID. If still unallocated, the input runes are allocated to the output
of the first edict.</p>
<p>If the invariant is not satisfied, the transaction does not signal RBF, the
transaction fails to leave a P2WPKH output for the private key <code>0x01</code> repeating,
or the P2WPKH output of the preceding conversion is unspent and not spent by this
transaction, the burned input runes are unburned and allocated according to the same
rules as the preceding paragraph.</p>
<p>An exception to this final condition is made for conversions in a block <code>P</code> in which
the first conversion cannot spend an output of a previous conversion. When this is case,
conversions in the block do not need to spend an output of the previous conversion
to be valid. The first conversion in the next block, however, must spend the output
created by the first conversion in block <code>P</code>.</p>
<h2 id="the-util"><a class="header" href="#the-util">The Util</a></h2>
<p>The util is the dynamic unit of account created by BitOMC. The util is a dynamic
sub-denomination of sats, determined by an interest rate that is controlled by
the relative quantity of Tighten and Ease. To calculate the number of utils per sat,
a second sub-denomination of sats is introduced, called the e-bond. The number of
e-bonds per sat increases monotically at the current interest rate. The number of
utils per sat is then determined by the number of utils per e-bond, which is 1 divided
by the interest rate.</p>
<h3 id="the-interest-rate"><a class="header" href="#the-interest-rate">The Interest Rate</a></h3>
<p>The interest rate equals the median value of <code>(A - B) / (A + B)</code> over the last 100 blocks
where <code>A &gt; B</code> and <code>(A - B) / (A + B)</code> is non-zero after integer division. <code>A</code> and <code>B</code> are
the supply of Tighten and Ease, respectively, and the value is calculated to 12 decimal
places. The default interest rate is 100%.</p>
<p>The number of e-bonds per sat is stored as an integer with 12 decimal places and updated
each block using the current interest rate divided by 52,595, which is approximately the
number of blocks per year.</p>
<h3 id="utils-per-sat"><a class="header" href="#utils-per-sat">Utils per Sat</a></h3>
<p>The number of utils per bond is calculated by dividing 10^24 by the interest rate in
integer form.</p>
<p>The number of utils per sat is calculated by multiplying the number of bonds per sat by
the number of utils per bond and dividing by 10^12.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-bitomc"><a class="header" href="#contributing-to-bitomc">Contributing to <code>bitomc</code></a></h1>
<h2 id="suggested-steps"><a class="header" href="#suggested-steps">Suggested Steps</a></h2>
<ol>
<li>Find an issue you want to work on.</li>
<li>Figure out what would be a good first step towards resolving the issue. This
could be in the form of code, research, a proposal, or suggesting that it be
closed, if it's out of date or not a good idea in the first place.</li>
<li>Comment on the issue with an outline of your suggested first step, and
asking for feedback. Of course, you can dive in and start writing code or
tests immediately, but this avoids potentially wasted effort, if the issue
is out of date, not clearly specified, blocked on something else, or
otherwise not ready to implement.</li>
<li>If the issue requires a code change or bugfix, open a draft PR with tests,
and ask for feedback. This makes sure that everyone is on the same page
about what needs to be done, or what the first step in solving the issue
should be. Also, since tests are required, writing the tests first makes it
easy to confirm that the change can be tested easily.</li>
<li>Mash the keyboard randomly until the tests pass, and refactor until the code
is ready to submit.</li>
<li>Mark the PR as ready to review.</li>
<li>Revise the PR as needed.</li>
<li>And finally, mergies!</li>
</ol>
<h2 id="start-small"><a class="header" href="#start-small">Start small</a></h2>
<p>Small changes will allow you to make an impact
quickly, and if you take the wrong tack, you won't have wasted much time.</p>
<p>Ideas for small issues:</p>
<ul>
<li>Add a new test or test case that increases test coverage</li>
<li>Add or improve documentation</li>
<li>Find an issue that needs more research, and do that research and summarize it
in a comment</li>
<li>Find an out-of-date issue and comment that it can be closed</li>
<li>Find an issue that shouldn't be done, and provide constructive feedback
detailing why you think that is the case</li>
</ul>
<h2 id="merge-early-and-often"><a class="header" href="#merge-early-and-often">Merge early and often</a></h2>
<p>Break up large tasks into multiple smaller steps that individually make
progress. If there's a bug, you can open a PR that adds a failing ignored test.
This can be merged, and the next step can be to fix the bug and unignore the
test. Do research or testing, and report on your results. Break a feature into
small sub-features, and implement them one at a time.</p>
<p>Figuring out how to break down a larger PR into smaller PRs where each can be
merged is an art form well-worth practicing. The hard part is that each PR must
itself be an improvement.</p>
<p>I strive to follow this advice myself, and am always better off when I do.</p>
<p>Small changes are fast to write, review, and merge, which is much more fun than
laboring over a single giant PR that takes forever to write, review, and merge.
Small changes don't take much time, so if you need to stop working on a small
change, you won't have wasted much time as compared to a larger change that
represents many hours of work. Getting a PR in quickly improves the project a
little bit immediately, instead of having to wait a long time for larger
improvement. Small changes are less likely to accumulate merge conflict. As the
Athenians said: <em>The fast commit what they will, the slow merge what they
must.</em></p>
<h2 id="get-help"><a class="header" href="#get-help">Get help</a></h2>
<p>If you're stuck for more than 15 minutes, ask for help, like a Rust Discord,
Stack Exchange, or in a project issue or discussion.</p>
<h2 id="practice-hypothesis-driven-debugging"><a class="header" href="#practice-hypothesis-driven-debugging">Practice hypothesis-driven debugging</a></h2>
<p>Formulate a hypothesis as to what is causing the problem. Figure out how to
test that hypothesis. Perform that tests. If it works, great, you fixed the
issue or now you know how to fix the issue. If not, repeat with a new
hypothesis.</p>
<h2 id="pay-attention-to-error-messages"><a class="header" href="#pay-attention-to-error-messages">Pay attention to error messages</a></h2>
<p>Read all error messages and don't tolerate warnings.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitomc-guides"><a class="header" href="#bitomc-guides">BitOMC Guides</a></h1>
<p>See the table of contents for a list of guides, including a guide to the
explorer and a guide to the wallet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet"><a class="header" href="#wallet">Wallet</a></h1>
<p>Tighten and Ease can be held in a Bitcoin wallet and
transferred using Bitcoin transactions. Utils are a floating denomination
of sats and can be transferred by transferring the equivalent number of sats.</p>
<p>BitOMC requires a Bitcoin node to give you a view of the current state of the
Bitcoin blockchain, and a wallet that can transfer utils, mint and convert Tighten
and Ease, and perform sat control when constructing transactions to send them to
another wallet.</p>
<p>Bitcoin Core provides both a Bitcoin node and wallet. However, the Bitcoin
Core wallet cannot mint or convert Tighten and Ease and does not perform sat control.</p>
<p>The utility <a href="https://github.com/BitOMC/BitOMC"><code>bitomc</code></a> doesn't implement its own
wallet, so <code>bitomc wallet</code> subcommands interact with Bitcoin Core wallets.</p>
<p>This guide covers:</p>
<ol>
<li>Installing Bitcoin Core</li>
<li>Syncing the Bitcoin blockchain</li>
<li>Creating a Bitcoin Core wallet</li>
<li>Using <code>bitomc wallet receive</code> to receive sats</li>
<li>Minting Tighten and Ease with <code>bitomc wallet mint</code></li>
<li>Converting Tighten and Ease with <code>bitomc wallet convert-exact-input</code> and <code>bitomc wallet convert-exact-output</code></li>
<li>Sending sats, utils, and Tighten and Ease with <code>bitomc wallet send</code></li>
<li>Receiving Tighten and Ease with <code>bitomc wallet receive</code></li>
</ol>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you get stuck, try asking for help on the <a href="https://discord.com/invite/87cjuz4FYg">Ordinals Discord
Server</a>, or checking GitHub for relevant
<a href="https://github.com/BitOMC/BitOMC/issues">issues</a> and
<a href="https://github.com/BitOMC/BitOMC/discussions">discussions</a>.</p>
<h2 id="installing-bitcoin-core"><a class="header" href="#installing-bitcoin-core">Installing Bitcoin Core</a></h2>
<p>Bitcoin Core is available from <a href="https://bitcoincore.org/">bitcoincore.org</a> on
the <a href="https://bitcoincore.org/en/download/">download page</a>.</p>
<p><code>bitomc</code> requires Bitcoin Core 24 or newer.</p>
<p>This guide does not cover installing Bitcoin Core in detail. Once Bitcoin Core
is installed, you should be able to run <code>bitcoind -version</code> successfully from
the command line. Do <em>NOT</em> use <code>bitcoin-qt</code>.</p>
<h2 id="configuring-bitcoin-core"><a class="header" href="#configuring-bitcoin-core">Configuring Bitcoin Core</a></h2>
<p><code>bitomc</code> requires Bitcoin Core's rest interface and block data. The <code>bitomc</code>
explorer also requires the transaction index, but the explorer is optional.</p>
<p>To configure your Bitcoin Core node to maintain a transaction
index, add the following to your <code>bitcoin.conf</code>:</p>
<pre><code>txindex=1
</code></pre>
<p>Or, run <code>bitcoind</code> with <code>-txindex</code>:</p>
<pre><code>bitcoind -txindex
</code></pre>
<p><code>bitomc</code> can be run on a Bitcoin Core node pruned below block 854500. Subsequent
blocks can be manually pruned after being indexed by <code>bitomc</code>, but doing so will
prevent <code>bitomc</code> from re-indexing.</p>
<p>Details on creating or modifying your <code>bitcoin.conf</code> file can be found
<a href="https://github.com/bitcoin/bitcoin/blob/master/doc/bitcoin-conf.md">here</a>.</p>
<h2 id="syncing-the-bitcoin-blockchain"><a class="header" href="#syncing-the-bitcoin-blockchain">Syncing the Bitcoin Blockchain</a></h2>
<p>To sync the chain, run:</p>
<pre><code>bitcoind
</code></pre>
<p>…and leave it running until <code>getblockcount</code>:</p>
<pre><code>bitcoin-cli getblockcount
</code></pre>
<p>agrees with the block count on a block explorer like <a href="https://mempool.space/">the mempool.space block
explorer</a>. <code>bitomc</code> interacts with <code>bitcoind</code>, so you
should leave <code>bitcoind</code> running in the background when you're using <code>bitomc</code>.</p>
<p>The blockchain takes about 600GB of disk space. If you have an external drive
you want to store blocks on, use the configuration option
<code>blocksdir=&lt;external_drive_path&gt;</code>. This is much simpler than using the
<code>datadir</code> option because the cookie file will still be in the default location
for <code>bitcoin-cli</code> and <code>bitomc</code> to find.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>Make sure you can access <code>bitcoind</code> with <code>bitcoin-cli -getinfo</code> and that it is
fully synced.</p>
<p>If <code>bitcoin-cli -getinfo</code> returns <code>Could not connect to the server</code>, <code>bitcoind</code>
is not running.</p>
<p>Make sure <code>rpcuser</code>, <code>rpcpassword</code>, or <code>rpcauth</code> are <em>NOT</em> set in your
<code>bitcoin.conf</code> file. <code>bitomc</code> requires using cookie authentication. Make sure there
is a file <code>.cookie</code> in your bitcoin data directory.</p>
<p>If <code>bitcoin-cli -getinfo</code> returns <code>Could not locate RPC credentials</code>, then you
must specify the cookie file location.
If you are using a custom data directory (specifying the <code>datadir</code> option),
then you must specify the cookie location like
<code>bitcoin-cli -rpccookiefile=&lt;your_bitcoin_datadir&gt;/.cookie -getinfo</code>.
When running <code>bitomc</code> you must specify the cookie file location with
<code>--cookie-file=&lt;your_bitcoin_datadir&gt;/.cookie</code>.</p>
<p>Make sure you do <em>NOT</em> have <code>disablewallet=1</code> in your <code>bitcoin.conf</code> file. If
<code>bitcoin-cli listwallets</code> returns <code>Method not found</code> then the wallet is disabled
and you won't be able to use <code>bitomc</code>.</p>
<p>If you have <code>maxuploadtarget</code> set it can interfere with fetching blocks for
<code>bitomc</code> index. Either remove it or set <code>whitebind=127.0.0.1:8333</code>.</p>
<h2 id="installing-bitomc"><a class="header" href="#installing-bitomc">Installing <code>bitomc</code></a></h2>
<p>The <code>bitomc</code> utility is written in Rust and can be built from
<a href="https://github.com/BitOMC/BitOMC">source</a>. Pre-built binaries are available on the
<a href="https://github.com/BitOMC/BitOMC/releases">releases page</a>.</p>
<p>You can install the latest pre-built binary from the command line with:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -fsLS https://bitomc.org/install.sh | bash -s
</code></pre>
<p>Once <code>bitomc</code> is installed, you should be able to run:</p>
<pre><code>bitomc --version
</code></pre>
<p>Which prints out <code>bitomc</code>'s version number.</p>
<h2 id="creating-a-wallet"><a class="header" href="#creating-a-wallet">Creating a Wallet</a></h2>
<p><code>bitomc</code> uses <code>bitcoind</code> to manage private keys, sign transactions, and
broadcast transactions to the Bitcoin network. Additionally the <code>bitomc wallet</code>
requires <code>bitomc server</code> running in the background. Make sure these
programs are running:</p>
<pre><code>bitcoind
</code></pre>
<pre><code>bitomc server
</code></pre>
<p>To create a wallet named <code>bitomc</code>, the default, for use with <code>bitomc wallet</code>, run:</p>
<pre><code>bitomc wallet create
</code></pre>
<p>This will print out your seed phrase mnemonic, store it somewhere safe.</p>
<pre><code>{
  "mnemonic": "dignity buddy actor toast talk crisp city annual tourist orient similar federal",
  "passphrase": ""
}
</code></pre>
<p>If you want to specify a different name or use an <code>bitomc server</code> running on a
non-default URL you can set these options:</p>
<pre><code>bitomc wallet --name foo --server-url http://127.0.0.1:8080 create
</code></pre>
<p>To see all available wallet options you can run:</p>
<pre><code>bitomc wallet help
</code></pre>
<h2 id="restoring-and-dumping-wallet"><a class="header" href="#restoring-and-dumping-wallet">Restoring and Dumping Wallet</a></h2>
<p>The <code>bitomc</code> wallet uses descriptors, so you can export the output descriptors and
import them into another descriptor-based wallet. To export the wallet
descriptors, which include your private keys:</p>
<pre><code>$ bitomc wallet dump
==========================================
= THIS STRING CONTAINS YOUR PRIVATE KEYS =
=        DO NOT SHARE WITH ANYONE        =
==========================================
{
  "wallet_name": "bitomc",
  "descriptors": [
    {
      "desc": "tr([551ac972/86'/1'/0']tprv8h4xBhrfZwX9o1XtUMmz92yNiGRYjF9B1vkvQ858aN1UQcACZNqN9nFzj3vrYPa4jdPMfw4ooMuNBfR4gcYm7LmhKZNTaF4etbN29Tj7UcH/0/*)#uxn94yt5",
      "timestamp": 1296688602,
      "active": true,
      "internal": false,
      "range": [
        0,
        999
      ],
      "next": 0
    },
    {
      "desc": "tr([551ac972/86'/1'/0']tprv8h4xBhrfZwX9o1XtUMmz92yNiGRYjF9B1vkvQ858aN1UQcACZNqN9nFzj3vrYPa4jdPMfw4ooMuNBfR4gcYm7LmhKZNTaF4etbN29Tj7UcH/1/*)#djkyg3mv",
      "timestamp": 1296688602,
      "active": true,
      "internal": true,
      "range": [
        0,
        999
      ],
      "next": 0
    }
  ]
}
</code></pre>
<p>An <code>bitomc</code> wallet can be restored from a mnemonic:</p>
<pre><code>bitomc wallet restore --from mnemonic
</code></pre>
<p>Type your mnemonic and press return.</p>
<p>To restore from a descriptor in <code>descriptor.json</code>:</p>
<pre><code>cat descriptor.json | bitomc wallet restore --from descriptor
</code></pre>
<p>To restore from a descriptor in the clipboard:</p>
<pre><code>bitomc wallet restore --from descriptor
</code></pre>
<p>Paste the descriptor into the terminal and press CTRL-D on unix and CTRL-Z
on Windows.</p>
<h2 id="receiving-sats"><a class="header" href="#receiving-sats">Receiving Sats</a></h2>
<p>Inscriptions are made on individual sats, using normal Bitcoin transactions
that pay fees in sats, so your wallet will need some sats.</p>
<p>Get a new address from your <code>bitomc</code> wallet by running:</p>
<pre><code>bitomc wallet receive
</code></pre>
<p>And send it some funds.</p>
<p>You can see pending transactions with:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Once the transaction confirms, you should be able to see the transactions
outputs with <code>bitomc wallet outputs</code>.</p>
<h2 id="minting-tighten-and-ease"><a class="header" href="#minting-tighten-and-ease">Minting Tighten and Ease</a></h2>
<p>To mint Tighten and Ease, run:</p>
<pre><code>bitomc wallet mint --fee-rate &lt;FEE_RATE&gt;
</code></pre>
<p>BitOMC will output the transaction ID, the amount of Tighten and Ease received,
and a <code>connected</code> boolean, which will be <code>true</code> if the transaction spends the
output left by the previous mint transaction. If so, the transaction will be
added to the mempool if and only if it is able to RBF the existing candidate mint
transaction (or if it is the first mint transaction seen). If <code>false</code>, the
transaction will only mint Tighten and Ease if it is the first transaction in the block.</p>
<p>You can check the status of the transactions using <a href="https://mempool.space/">the mempool.space block
explorer</a>.</p>
<p>Once the transaction has been mined, you can confirm receipt by running:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="converting-tighten-and-ease"><a class="header" href="#converting-tighten-and-ease">Converting Tighten and Ease</a></h2>
<p>To convert between Tighten and Ease using an exact input amount, run:</p>
<pre><code>bitomc wallet convert-exact-input --fee-rate &lt;INPUT_AMOUNT&gt; &lt;MIN_OUTPUT_AMOUNT&gt;
</code></pre>
<p>Where <code>INPUT_AMOUNT</code> is the number of runes to convert, a <code>:</code> character, and the
name of the input rune, and <code>MIN_OUTPUT_AMOUNT</code> is the minimum number of runes
you wish to receive, a <code>:</code> character, and the name of the output rune.</p>
<p>For example, if you want to convert 1000 TIGHTEN and receive at least 500 EASE, you
would use <code>1000:TIGHTEN</code> and <code>500:EASE</code>.</p>
<pre><code>bitomc wallet convert-exact-input --fee-rate 1 1000:TIGHTEN 500:EASE
</code></pre>
<p>Alternatively, if you want to convert 1000 TIGHTEN at the latest conversion rate, you
would use <code>1000:TIGHTEN</code> and <code>0:EASE</code>.</p>
<pre><code>bitomc wallet convert-exact-input --fee-rate 1 1000:TIGHTEN 0:EASE
</code></pre>
<p>To convert between Tighten and Ease using an exact output amount, run:</p>
<pre><code>bitomc wallet convert-exact-input --fee-rate &lt;OUTPUT_AMOUNT&gt; &lt;MAX_INPUT_AMOUNT&gt;
</code></pre>
<p>BitOMC will output the transaction ID, the expected amount of Tighten and Ease received,
and a <code>connected</code> boolean, which will be <code>true</code> if and only if the transaction spends the
output left by the preceding conversion transaction.</p>
<p>You can check the status of the transactions using <a href="https://mempool.space/">the mempool.space block
explorer</a>.</p>
<p>Once the transaction has been mined, you can confirm receipt by running:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="sending-sats"><a class="header" href="#sending-sats">Sending Sats</a></h2>
<p>Send sats by running:</p>
<pre><code>bitomc wallet send --fee-rate &lt;FEE_RATE&gt; &lt;ADDRESS&gt; &lt;SAT_AMOUNT&gt;
</code></pre>
<p>Where <code>SAT_AMOUNT</code> is the amount of sats to send, an optional space, and the
denomination (<code>bit|btc|cbtc|mbtc|msat|nbtc|pbtc|sat|satoshi|ubtc</code>). For example if you
want to send 1000 sats, you would use <code>1000 sats</code>.</p>
<pre><code>bitomc wallet send --fee-rate 1 SOME_ADDRESS 1000 sats
</code></pre>
<p>See the pending transaction with:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Once the send transaction confirms, the recipient can confirm receipt by
running:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="sending-utils"><a class="header" href="#sending-utils">Sending Utils</a></h2>
<p>Send utils by running:</p>
<pre><code>bitomc wallet send --fee-rate &lt;FEE_RATE&gt; &lt;ADDRESS&gt; &lt;UTIL_AMOUNT&gt;
</code></pre>
<p>Where <code>UTIL_AMOUNT</code> is the amount of sats to send, an optional space, and the denomination
<code>util</code> or <code>utils</code>. For example if you want to send 1000 utils, you would use <code>1000 utils</code>.</p>
<pre><code>bitomc wallet send --fee-rate 1 SOME_ADDRESS 1000 utils
</code></pre>
<p>See the pending transaction with:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Once the send transaction confirms, the recipient can confirm receipt by
running:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="sending-tighten-and-ease"><a class="header" href="#sending-tighten-and-ease">Sending Tighten and Ease</a></h2>
<p>Ask the recipient to generate a new address by running:</p>
<pre><code>bitomc wallet receive
</code></pre>
<p>Send the runes by running:</p>
<pre><code>bitomc wallet send --fee-rate &lt;FEE_RATE&gt; &lt;ADDRESS&gt; &lt;RUNES_AMOUNT&gt;
</code></pre>
<p>Where <code>RUNES_AMOUNT</code> is the number of runes to send, a <code>:</code> character, and the
name of the rune. For example if you want to send 1000 of TIGHTEN, you
would use <code>1000:TIGHTEN</code>.</p>
<pre><code>bitomc wallet send --fee-rate 1 SOME_ADDRESS 1000:EXAMPLE
</code></pre>
<p>Likewise, if you want to send 1000 of EASE, you
would use <code>1000:EASE</code>.</p>
<pre><code>bitomc wallet send --fee-rate 1 SOME_ADDRESS 1000:EASE
</code></pre>
<p>See the pending transaction with:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Once the send transaction confirms, the recipient can confirm receipt with:</p>
<pre><code>bitomc wallet balance
</code></pre>
<h2 id="receiving-runes"><a class="header" href="#receiving-runes">Receiving Runes</a></h2>
<p>Generate a new receive address using:</p>
<pre><code>bitomc wallet receive
</code></pre>
<p>The sender can transfer the rune to your address using:</p>
<pre><code>bitomc wallet send --fee-rate &lt;FEE_RATE&gt; &lt;ADDRESS&gt; &lt;RUNES_AMOUNT&gt;
</code></pre>
<p>See the pending transaction with:</p>
<pre><code>bitomc wallet transactions
</code></pre>
<p>Once the send transaction confirms, you can confirm receipt by running:</p>
<pre><code>bitomc wallet balance
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reindexing"><a class="header" href="#reindexing">Reindexing</a></h1>
<p>Sometimes the <code>bitomc</code> database must be reindexed, which means deleting the
database and restarting the indexing process with either <code>bitomc index update</code> or
<code>bitomc server</code>. Reasons to reindex are:</p>
<ol>
<li>A new major release of bitomc, which changes the database scheme</li>
<li>The database got corrupted somehow</li>
</ol>
<p>The database <code>bitomc</code> uses is called <a href="https://github.com/cberner/redb">redb</a>,
so we give the index the default file name <code>index.redb</code>. By default we store this
file in different locations depending on your operating system.</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Value</th><th>Example</th></tr></thead><tbody>
<tr><td>Linux</td><td><code>$XDG_DATA_HOME</code>/bitomc or <code>$HOME</code>/.local/share/bitomc</td><td>/home/alice/.local/share/bitomc</td></tr>
<tr><td>macOS</td><td><code>$HOME</code>/Library/Application Support/bitomc</td><td>/Users/Alice/Library/Application Support/bitomc</td></tr>
<tr><td>Windows</td><td><code>{FOLDERID_RoamingAppData}</code>\bitomc</td><td>C:\Users\Alice\AppData\Roaming\bitomc</td></tr>
</tbody></table>
</div>
<p>So to delete the database and reindex on MacOS you would have to run the following
commands in the terminal:</p>
<pre><code class="language-bash">rm ~/Library/Application Support/bitomc/index.redb
bitomc index update
</code></pre>
<p>You can of course also set the location of the data directory yourself with <code>bitomc --datadir &lt;DIR&gt; index update</code> or give it a specific filename and path with <code>bitomc --index &lt;FILENAME&gt; index update</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<p><code>bitomc</code> can be configured with the command line, environment variables, a
configuration file, and default values.</p>
<p>The command line takes precedence over environment variables, which take
precedence over the configuration file, which takes precedence over defaults.</p>
<p>The path to the configuration file can be given with <code>--config &lt;CONFIG_PATH&gt;</code>.
<code>bitomc</code> will error if <code>&lt;CONFIG_PATH&gt;</code> doesn't exist.</p>
<p>The path to a directory containing a configuration file name named <code>bitomc.yaml</code>
can be given with <code>--config-dir &lt;CONFIG_DIR_PATH&gt;</code> or <code>--datadir &lt;DATA_DIR_PATH&gt;</code> in which case the config path is <code>&lt;CONFIG_DIR_PATH&gt;/bitomc.yaml</code>
or <code>&lt;DATA_DIR_PATH&gt;/bitomc.yaml</code>. It is not an error if it does not exist.</p>
<p>If none of <code>--config</code>, <code>--config-dir</code>, or <code>--datadir</code> are given, and a file
named <code>bitomc.yaml</code> exists in the default data directory, it will be loaded.</p>
<p>For a setting named <code>--setting-name</code> on the command line, the environment
variable will be named <code>BITOMC_SETTING_NAME</code>, and the config file field will be
named <code>setting_name</code>. For example, the data directory can be configured with
<code>--datadir</code> on the command line, the <code>BITOMC_DATA_DIR</code> environment variable, or
<code>data_dir</code> in the config file.</p>
<p>See <code>bitomc --help</code> for documentation of all the settings.</p>
<p><code>bitomc</code>'s current configuration can be viewed as JSON with the <code>bitomc settings</code>
command.</p>
<h2 id="example-configuration"><a class="header" href="#example-configuration">Example Configuration</a></h2>
<pre><code class="language-yaml"># example config

# see `bitomc --help` for setting documentation

bitcoin_data_dir: /var/lib/bitcoin
bitcoin_rpc_password: bar
bitcoin_rpc_url: https://localhost:8000
bitcoin_rpc_username: foo
chain: mainnet
commit_interval: 10000
config: /var/lib/bitomc/bitomc.yaml
config_dir: /var/lib/bitomc
cookie_file: /var/lib/bitcoin/.cookie
data_dir: /var/lib/bitomc
first_rune_height: 100
height_limit: 1000
index: /var/lib/bitomc/index.redb
index_addresses: false
index_cache_size: 1000000000
index_transactions: false
integration_test: true
server_password: bar
server_url: http://localhost:8888
server_username: foo
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<h2 id="test-environment"><a class="header" href="#test-environment">Test Environment</a></h2>
<p><code>bitomc env &lt;DIRECTORY&gt;</code> creates a test environment in <code>&lt;DIRECTORY&gt;</code>, spins up
<code>bitcoind</code> and <code>bitomc server</code> instances, prints example commands for interacting
with the test <code>bitcoind</code> and <code>bitomc server</code> instances, waits for <code>CTRL-C</code>, and
then shuts down <code>bitcoind</code> and <code>bitomc server</code>.</p>
<p><code>bitomc env</code> tries to use port 9000 for <code>bitcoind</code>'s RPC interface, and port
<code>9001</code> for <code>bitomc</code>'s RPC interface, but will fall back to random unused ports.</p>
<p>Inside of the env directory, <code>bitomc env</code> will write <code>bitcoind</code>'s configuration to
<code>bitcoin.conf</code>, <code>bitomc</code>'s configuration to <code>bitomc.yaml</code>, and the env configuration
to <code>env.json</code>.</p>
<p><code>env.json</code> contains the commands needed to invoke <code>bitcoin-cli</code> and <code>bitomc wallet</code>, as well as the ports <code>bitcoind</code> and <code>bitomc server</code> are listening on.</p>
<p>These can be extracted into shell commands using <code>jq</code>:</p>
<pre><code class="language-shell">bitcoin=`jq -r '.bitcoin_cli_command | join(" ")' env/env.json`
$bitcoin listunspent

bitomc=`jq -r '.ord_wallet_command | join(" ")' env/env.json`
$bitomc outputs
</code></pre>
<p>If <code>bitomc</code> is in the <code>$PATH</code> and the env directory is <code>env</code>, the <code>bitcoin-cli</code>
command will be:</p>
<pre><code>bitcoin-cli -datadir=env`
</code></pre>
<p>And the <code>bitomc</code> will be:</p>
<pre><code>bitomc --datadir env
</code></pre>
<h2 id="test-networks"><a class="header" href="#test-networks">Test Networks</a></h2>
<p>BitOMC can be tested using the following flags to specify the test network. For more
information on running Bitcoin Core for testing, see <a href="https://developer.bitcoin.org/examples/testing.html">Bitcoin's developer documentation</a>.</p>
<p>Most <code>bitomc</code> commands in <a href="guides/wallet.html">wallet</a> can be run with the following network flags:</p>
<div class="table-wrapper"><table><thead><tr><th>Network</th><th>Flag</th></tr></thead><tbody>
<tr><td>Testnet</td><td><code>--testnet</code> or <code>-t</code></td></tr>
<tr><td>Signet</td><td><code>--signet</code> or <code>-s</code></td></tr>
<tr><td>Regtest</td><td><code>--regtest</code> or <code>-r</code></td></tr>
</tbody></table>
</div>
<p>Regtest doesn't require downloading the blockchain since you create your own
private blockchain, so indexing <code>bitomc</code> is almost instantaneous.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Run <code>bitcoind</code> in regtest with:</p>
<pre><code>bitcoind -regtest -txindex
</code></pre>
<p>Run <code>bitomc server</code> in regtest with:</p>
<pre><code>bitomc --regtest server
</code></pre>
<p>Create a wallet in regtest with:</p>
<pre><code>bitomc --regtest wallet create
</code></pre>
<p>Get a regtest receive address with:</p>
<pre><code>bitomc --regtest wallet receive
</code></pre>
<p>Mine 101 blocks (to unlock the coinbase) with:</p>
<pre><code>bitcoin-cli -regtest generatetoaddress 101 &lt;receive address&gt;
</code></pre>
<p>Mint in regtest with:</p>
<pre><code>bitomc --regtest wallet mint --fee-rate 1
</code></pre>
<p>Mine the transaction with:</p>
<pre><code>bitcoin-cli -regtest generatetoaddress 1 &lt;receive address&gt;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
